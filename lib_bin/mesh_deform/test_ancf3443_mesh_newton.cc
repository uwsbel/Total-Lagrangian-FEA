/**
 * ANCF3443 Mesh Demo (Newton)
 *
 * Loads a `.ancf3443mesh` shell mesh, uploads any linear constraints from the
 * mesh file, clamps the inner spoke nodes (hub attachment), and runs a few
 * Newton steps. Intended for meshes generated by:
 *   `test-scripts/3443-shell/airless_tire_mesh_gen.py`
 *
 * Example:
 *   bazel run //lib_bin/mesh_deform:test_ancf3443_mesh_newton -- \
 *     --mesh=test-scripts/3443-shell/airless_tire.ancf3443mesh --vtu
 */

#include <cuda_runtime.h>

#include <Eigen/Dense>
#include <algorithm>
#include <cmath>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <limits>
#include <sstream>
#include <string>
#include <vector>

#include "../../lib_src/elements/ANCF3443Data.cuh"
#include "../../lib_src/solvers/SyncedNewton.cuh"
#include "../../lib_utils/cli_utils.h"
#include "../../lib_utils/mesh_utils.h"
#include "../../lib_utils/quadrature_utils.h"
#include "../../lib_utils/visualization_utils.h"

namespace {

constexpr double kE    = 1e8;
constexpr double kNu   = 0.33;
constexpr double kRho0 = 2000;

// Kelvin-Voigt damping coefficients used in `compute_p()` for viscous stress.
// Empirical demo values; increase for more numerical stabilization.
constexpr double kEtaDamp    = 5e4;
constexpr double kLambdaDamp = 5e4;

constexpr int kVtuEvery          = 5;
constexpr const char* kVtuPrefix = "ancf3443_mesh";

struct Options {
  std::string mesh_path;
  int steps      = 10;
  double dt      = 1e-3;
  bool write_vtu = false;

  // Ground contact (penalty) on ring nodes only:
  //   fz = k * max(0, ground_z - z)
  bool apply_load_below_z = true;
  double load_below_z     = -0.2;  // ground plane z
  double load_fz          = 5e4;   // contact stiffness (N/m) per node
  double contact_fz_max = 2e4;  // clamp per-node force (N), <=0 disables clamp

  // Legacy flags kept for compatibility (ignored for ground-contact mode).
  bool load_per_node = true;
  double load_fx     = 0.0;
  double load_fy     = 0.0;
};

double RadiusXZ(const ANCFCPUUtils::ANCF3443Mesh& mesh, int node_id) {
  const double x = mesh.x12(4 * node_id + 0);
  const double z = mesh.z12(4 * node_id + 0);
  return std::hypot(x, z);
}

double Smoothstep01(double s) {
  const double x = std::clamp(s, 0.0, 1.0);
  return x * x * (3.0 - 2.0 * x);
}

void RotateAboutY(double theta, double& x, double& y, double& z) {
  const double c  = std::cos(theta);
  const double sn = std::sin(theta);
  const double x0 = x;
  const double z0 = z;
  x               = c * x0 + sn * z0;
  // y unchanged
  z = -sn * x0 + c * z0;
}

int ApplyGroundContactRing(Eigen::VectorXd& f_ext,
                           const ANCFCPUUtils::ANCF3443Mesh& mesh,
                           const Eigen::VectorXd& z12, double ground_z,
                           double k, double fz_max) {
  if (static_cast<int>(mesh.node_family.size()) != mesh.n_nodes) {
    return 0;
  }
  std::vector<int> nodes;
  nodes.reserve(static_cast<size_t>(mesh.n_nodes));
  for (int nid = 0; nid < mesh.n_nodes; ++nid) {
    if (mesh.node_family[static_cast<size_t>(nid)] != "R") {
      continue;
    }
    const double z = z12(4 * nid + 0);
    if (z < ground_z) {
      nodes.push_back(nid);
    }
  }
  if (nodes.empty()) {
    return 0;
  }

  for (int nid : nodes) {
    const double z   = z12(4 * nid + 0);
    const double pen = (ground_z - z);
    double fz        = k * pen;
    if (fz_max > 0.0) {
      fz = std::min(fz, fz_max);
    }
    const int coef = nid * 4;  // position coefficient
    f_ext(coef * 3 + 2) += fz;
  }
  return static_cast<int>(nodes.size());
}

std::vector<int> FindInnerSpokeNodes(const ANCFCPUUtils::ANCF3443Mesh& mesh) {
  if (static_cast<int>(mesh.node_family.size()) != mesh.n_nodes) {
    return {};
  }

  double r_min = std::numeric_limits<double>::infinity();
  for (int nid = 0; nid < mesh.n_nodes; ++nid) {
    if (mesh.node_family[static_cast<size_t>(nid)] != "S") {
      continue;
    }
    r_min = std::min(r_min, RadiusXZ(mesh, nid));
  }
  if (!std::isfinite(r_min)) {
    return {};
  }

  const double tol = std::max(1e-12, 1e-8 * std::max(1.0, r_min));
  std::vector<int> nodes;
  nodes.reserve(static_cast<size_t>(mesh.n_nodes));
  for (int nid = 0; nid < mesh.n_nodes; ++nid) {
    if (mesh.node_family[static_cast<size_t>(nid)] != "S") {
      continue;
    }
    const double r = RadiusXZ(mesh, nid);
    if ((r - r_min) > tol) {
      continue;
    }
    nodes.push_back(nid);
  }

  std::cout << "Hub nodes (inner spoke nodes): r_min=" << r_min
            << " tol=" << tol << " nodes=" << nodes.size() << std::endl;
  return nodes;
}

}  // namespace

int main(int argc, char** argv) {
  Options opt;
  ANCFCPUUtils::Cli cli(argv[0]);
  cli.SetDescription(
      "ANCF3443 airless tire demo: hub rotation (prescribed) + optional ground "
      "contact on ring nodes.");
  cli.AddString("mesh", "", "path to .ancf3443mesh (required)");
  cli.AddInt("steps", opt.steps, "number of Solve() calls");
  cli.AddDouble("dt", opt.dt, "time step");
  cli.AddBool("vtu", opt.write_vtu,
              "write VTU meshes to output/ancf3443_mesh/ (every 5 steps)");

  cli.AddBool("apply_load_below_z", opt.apply_load_below_z,
              "enable ground contact on ring nodes");
  cli.AddDouble("load_below_z", opt.load_below_z, "ground plane z");
  cli.AddDouble("load_fz", opt.load_fz,
                "contact stiffness K (N/m) per ring node");
  cli.AddDouble("contact_fz_max", opt.contact_fz_max,
                "clamp per-node contact force (N); <=0 disables clamp");

  // Legacy options (kept for backwards compatibility; ignored).
  cli.AddBool("load_per_node", opt.load_per_node,
              "(legacy; ignored) previously selected force interpretation");
  cli.AddDouble("load_fx", opt.load_fx, "(legacy; ignored)");
  cli.AddDouble("load_fy", opt.load_fy, "(legacy; ignored)");

  std::string cli_err;
  if (!cli.Parse(argc, argv, &cli_err) || cli.HelpRequested()) {
    if (!cli_err.empty()) {
      std::cerr << cli_err << "\n\n";
    }
    cli.PrintUsage(std::cout);
    return cli.HelpRequested() ? 0 : 1;
  }

  opt.mesh_path          = cli.GetString("mesh");
  opt.steps              = cli.GetInt("steps");
  opt.dt                 = cli.GetDouble("dt");
  opt.write_vtu          = cli.GetBool("vtu");
  opt.apply_load_below_z = cli.GetBool("apply_load_below_z");
  opt.load_below_z       = cli.GetDouble("load_below_z");
  opt.load_fz            = cli.GetDouble("load_fz");
  opt.contact_fz_max     = cli.GetDouble("contact_fz_max");

  opt.load_per_node = cli.GetBool("load_per_node");
  opt.load_fx       = cli.GetDouble("load_fx");
  opt.load_fy       = cli.GetDouble("load_fy");

  if (opt.mesh_path.empty()) {
    std::cerr << "--mesh is required\n";
    return 2;
  }
  if (!std::filesystem::exists(opt.mesh_path)) {
    std::cerr << "Mesh file not found: " << opt.mesh_path << "\n";
    return 2;
  }
  if (opt.steps <= 0) {
    std::cerr << "Invalid --steps (must be > 0): " << opt.steps << "\n";
    return 2;
  }
  if (!(opt.dt > 0.0)) {
    std::cerr << "Invalid --dt (must be > 0): " << opt.dt << "\n";
    return 2;
  }

  ANCFCPUUtils::ANCF3443Mesh mesh;
  std::string err;
  if (!ANCFCPUUtils::ReadANCF3443MeshFromFile(opt.mesh_path, mesh, &err)) {
    std::cerr << err << "\n";
    return 2;
  }

  if (opt.write_vtu) {
    std::filesystem::create_directories("output/ancf3443_mesh");
  }

  std::cout << "ANCF3443 mesh: mesh=" << opt.mesh_path
            << " nodes=" << mesh.n_nodes << " elements=" << mesh.n_elements
            << " coef=" << (4 * mesh.n_nodes)
            << " constraints(from mesh)=" << mesh.constraints.NumRows()
            << " steps=" << opt.steps << " dt=" << opt.dt << std::endl;

  constexpr double kThicknessScale = 0.25;  // reduce thickness by 4x
  Eigen::VectorXd element_H_scaled = mesh.element_H;
  if (element_H_scaled.size() > 0) {
    element_H_scaled *= kThicknessScale;
  }

  GPU_ANCF3443_Data data(mesh.n_nodes, mesh.n_elements);
  data.Initialize();

  data.Setup(mesh.element_L, mesh.element_W, element_H_scaled,
             Quadrature::gauss_xi_m_7, Quadrature::gauss_eta_m_7,
             Quadrature::gauss_zeta_m_3, Quadrature::gauss_xi_4,
             Quadrature::gauss_eta_4, Quadrature::gauss_zeta_3,
             Quadrature::weight_xi_m_7, Quadrature::weight_eta_m_7,
             Quadrature::weight_zeta_m_3, Quadrature::weight_xi_4,
             Quadrature::weight_eta_4, Quadrature::weight_zeta_3, mesh.x12,
             mesh.y12, mesh.z12, mesh.element_connectivity);

  data.SetDensity(kRho0);
  data.SetDamping(kEtaDamp, kLambdaDamp);
  data.SetSVK(kE, kNu);

  const int n_coef = 4 * mesh.n_nodes;
  const int n_dofs = n_coef * 3;

  std::unique_ptr<ANCFCPUUtils::LinearConstraintBuilder> builder;
  if (mesh.constraints.Empty()) {
    builder = std::make_unique<ANCFCPUUtils::LinearConstraintBuilder>(n_dofs);
  } else {
    builder = std::make_unique<ANCFCPUUtils::LinearConstraintBuilder>(
        n_dofs, mesh.constraints);
  }

  const std::vector<int> hub_nodes = FindInnerSpokeNodes(mesh);
  const int hub_row0               = builder->num_rows();
  std::vector<int> hub_coef_indices;
  hub_coef_indices.reserve(static_cast<size_t>(hub_nodes.size()) * 4);
  for (int nid : hub_nodes) {
    for (int slot = 0; slot < 4; ++slot) {
      const int coef = 4 * nid + slot;
      hub_coef_indices.push_back(coef);
      ANCFCPUUtils::AppendANCF3243FixedCoefficient(*builder, coef, mesh.x12,
                                                   mesh.y12, mesh.z12);
    }
  }
  std::cout << "Hub prescribed rotation: coef_fixed=" << hub_coef_indices.size()
            << " rows=" << (3 * hub_coef_indices.size()) << std::endl;
  const ANCFCPUUtils::LinearConstraintCSR all_constraints = builder->ToCSR();
  data.SetLinearConstraintsCSR(all_constraints.offsets, all_constraints.columns,
                               all_constraints.values, all_constraints.rhs);

  data.CalcDsDuPre();
  data.CalcMassMatrix();
  data.CalcConstraintData();
  {
    Eigen::VectorXd c;
    data.RetrieveConstraintDataToCPU(c);
    double linf = 0.0;
    for (int i = 0; i < c.size(); ++i) {
      linf = std::max(linf, std::abs(c(i)));
    }
    std::cout << "Constraint residual: rows=" << c.size()
              << " ||c||_2=" << c.norm() << " ||c||_inf=" << linf << std::endl;
  }
  data.CalcP();
  data.CalcInternalForce();

  auto want_vtu = [&](int step) {
    return opt.write_vtu && (step % kVtuEvery) == 0;
  };

  auto write_vtu = [&](int step, const Eigen::VectorXd& x12,
                       const Eigen::VectorXd& y12, const Eigen::VectorXd& z12) {
    std::ostringstream oss;
    oss << "output/ancf3443_mesh/" << kVtuPrefix << "_" << std::setw(6)
        << std::setfill('0') << step << ".vtu";
    double thickness = 0.0;
    if (element_H_scaled.size() > 0) {
      thickness = element_H_scaled.maxCoeff();
    }
    if (!(thickness > 0.0)) {
      thickness = 1e-3;
    }
    ANCFCPUUtils::VisualizationUtils::ExportANCF3443ToVTU(
        x12, y12, z12, mesh.element_connectivity, thickness, oss.str());
  };

  // Note: very large rho can make the KKT/Hessian ill-conditioned and trigger
  // NaNs/overflow. Start moderate and increase only if needed.
  SyncedNewtonParams params = {1e-4, 0.0, 1e-6, 1e12, 10, 10, opt.dt};
  SyncedNewtonSolver solver(&data, data.get_n_constraint());
  solver.Setup();
  solver.SetParameters(&params);

  Eigen::VectorXd rhs_base = all_constraints.rhs;
  Eigen::VectorXd rhs      = rhs_base;

  constexpr double kOmegaTarget   = 1.5 * 3.14159265358979323846;  // pi/2 rad/s
  constexpr double kOmegaRampTime = 0.05;                          // seconds
  double theta                    = 0.0;

  if (opt.write_vtu) {
    Eigen::VectorXd x12, y12, z12;
    data.RetrievePositionToCPU(x12, y12, z12);
    write_vtu(0, x12, y12, z12);
  }

  for (int step = 0; step < opt.steps; ++step) {
    Eigen::VectorXd x12, y12, z12;
    data.RetrievePositionToCPU(x12, y12, z12);

    Eigen::VectorXd h_f_ext(4 * mesh.n_nodes * 3);
    h_f_ext.setZero();
    if (opt.apply_load_below_z) {
      const int count =
          ApplyGroundContactRing(h_f_ext, mesh, z12, opt.load_below_z,
                                 opt.load_fz, opt.contact_fz_max);
      (void)count;
    }
    data.SetExternalForce(h_f_ext);

    // Prescribed hub rotation: update RHS for the hub fixed rows so that the
    // inner spoke nodes follow a ramped rotation about +Y.
    const double t_mid = (static_cast<double>(step) + 0.5) * opt.dt;
    const double omega = kOmegaTarget * Smoothstep01(t_mid / kOmegaRampTime);
    theta += omega * opt.dt;
    if (!hub_coef_indices.empty()) {
      rhs = rhs_base;
      for (size_t i = 0; i < hub_coef_indices.size(); ++i) {
        const int coef = hub_coef_indices[i];
        double x       = mesh.x12(coef);
        double y       = mesh.y12(coef);
        double z       = mesh.z12(coef);
        RotateAboutY(theta, x, y, z);
        const int row0 = hub_row0 + static_cast<int>(3 * i);
        rhs(row0 + 0)  = x;
        rhs(row0 + 1)  = y;
        rhs(row0 + 2)  = z;
      }
      data.UpdateLinearConstraintRHS(rhs);
    }

    solver.Solve();
    const int out_step = step + 1;
    if (want_vtu(out_step)) {
      data.RetrievePositionToCPU(x12, y12, z12);
      write_vtu(out_step, x12, y12, z12);
    }
  }

  data.Destroy();
  return 0;
}
